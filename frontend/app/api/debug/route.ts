import { NextResponse } from 'next/server';
import { getAdminFirestore } from '@/lib/firebase-admin';

export const dynamic = 'force-dynamic';

export async function GET() {
    const envCheck = {
        hasDiscordId: !!process.env.DISCORD_CLIENT_ID,
        hasDiscordSecret: !!process.env.DISCORD_CLIENT_SECRET,
        hasAuthSecret: !!process.env.AUTH_SECRET,
        hasServiceAccount: !!process.env.FIREBASE_SERVICE_ACCOUNT_KEY,
        serviceAccountLength: process.env.FIREBASE_SERVICE_ACCOUNT_KEY?.length || 0,
    };

    try {
        const db = getAdminFirestore();
        const collections = await db.listCollections();
        const collectionNames = collections.map(c => c.id);

        return NextResponse.json({
            status: 'success',
            message: 'Connected to Firestore!',
            collections: collectionNames,
            env: envCheck
        });
    } catch (error: any) {
        return NextResponse.json({
            status: 'error',
            message: error.message,
            stack: error.stack,
            env: envCheck
        }, { status: 500 });
    }
}

export async function POST() {
    try {
        const db = getAdminFirestore();
        const batch = db.batch();

        // 1. Create Bot Users
        const bots = [
            { id: 'bot_gamma', name: 'Gamma', school: 'Storm' },
            { id: 'bot_merle', name: 'Headmaster Ambrose', school: 'Balance' },
            { id: 'bot_cyrus', name: 'Cyrus Drake', school: 'Myth' },
            { id: 'bot_dworgyn', name: 'Dworgyn', school: 'Death' }
        ];

        for (const bot of bots) {
            batch.set(db.collection('users').doc(bot.id), {
                displayName: bot.name,
                school: bot.school,
                lastSeen: new Date(),
                isBot: true
            }, { merge: true });
        }

        // 2. Create Listings
        const listingTypes = ['tc_pack', 'pet_lend', 'carry_service'];
        const petNames = ['Mega Storm Pet', 'Triple Double Myth', 'Ward Pet', 'Damage Quint'];
        const curs = ['empowers'];

        for (let i = 0; i < 20; i++) {
            const bot = bots[Math.floor(Math.random() * bots.length)];
            const type = listingTypes[Math.floor(Math.random() * listingTypes.length)];
            const ref = db.collection('market_listings').doc();
            
            const listing = {
                id: ref.id,
                sellerId: bot.id,
                sellerName: bot.name,
                ownerDisplayName: bot.name, // For some queries
                userId: bot.id, // For some queries
                type: type,
                title: type === 'pet_lend' ? petNames[Math.floor(Math.random() * petNames.length)] : `${(Math.floor(Math.random() * 5) + 1) * 10}x Empowers`,
                description: 'Generated by Seed Script',
                batchSize: 1,
                availableBatches: Math.floor(Math.random() * 5) + 1,
                allowPartial: true,
                currency: 'empowers',
                pricePerBatch: Math.floor(Math.random() * 100) + 10,
                status: 'active',
                createdAt: new Date(Date.now() - Math.floor(Math.random() * 10000000)), // Random past time
                listedAt: new Date(),
                ownerLastSeen: new Date().toISOString()
            };

            batch.set(ref, listing);
        }

        await batch.commit();

        return NextResponse.json({
            status: 'success',
            message: 'Marketplace Seeded with 4 Bots and 20 Listings.'
        });
    } catch (error: any) {
        return NextResponse.json({
            status: 'error',
            message: error.message
        }, { status: 500 });
    }
}
